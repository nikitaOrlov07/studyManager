package com.example.courseservice.Service.impl;

import com.example.courseservice.Config.exceptions.CourseCreationException;
import com.example.courseservice.Config.exceptions.ResourceNotFoundException;
import com.example.courseservice.Dto.Course.CourseCreationRequest;
import com.example.courseservice.Dto.Course.CourseResponse;
import com.example.courseservice.Dto.UserEntity.UserEntityResponse;
import com.example.courseservice.Mappers.CourseMapper;
import com.example.courseservice.Mappers.UsersMapper;
import com.example.courseservice.Model.Attachment;
import com.example.courseservice.Model.Course;
import com.example.courseservice.Model.Homework;
import com.example.courseservice.Repository.CourseRepository;
import com.example.courseservice.Service.AttachmentService;
import com.example.courseservice.Service.CourseService;
import com.example.courseservice.Service.HomeworkService;
import com.example.courseservice.Service.UserService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.time.format.DateTimeFormatter;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class CourseServiceImpl implements CourseService {

    private final CourseRepository courseRepository;
    private final AttachmentService attachmentService;
    private final WebClient.Builder webClientBuilder; // for HTTP requests
    private final UserService userService;

    @Lazy // lazy initialization to prevent circular references
    @Autowired
    private  HomeworkService homeworkService;

    @Override
    public List<Course> getAllCourses() {
        log.info("getAllCourses service method is working ");
        return courseRepository.findAll();
    }

    @Override
    @Transactional
    public Course createCourse(CourseCreationRequest courseCreationRequest) {
        // Parsing tags string to List
        List<String> tags = new ArrayList<>();
        if (courseCreationRequest.getTags() != null && !courseCreationRequest.getTags().isEmpty()) {
            tags.addAll(Arrays.asList(courseCreationRequest.getTags().split(",")));
        }
        // check if course with this title is already exists
        Course existingCourse = courseRepository.findByTitle(courseCreationRequest.getTitle());
        if(existingCourse != null)
        {
            throw new CourseCreationException("Course with title " + existingCourse.getTitle()+ " already exists");
        }

        // Get creation date
        LocalDate currentDate = LocalDate.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd MM yyyy");
        String formattedDate = currentDate.format(formatter);

        // Http request to userService to find a current user

        // HTTP request
        ResponseEntity<UserEntityResponse> response = webClientBuilder.build()
                .get()  // Changed from post to get
                .uri("http://user-service/users/{username}", courseCreationRequest.getAuthor())  // Adjust the URI as needed
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .toEntity(UserEntityResponse.class)
                .block();

        if(response == null)
        {
            throw new CourseCreationException("Author not found");
        }


        Course course = Course.builder()
                .title(courseCreationRequest.getTitle())
                .description(courseCreationRequest.getDescription())
                .price(courseCreationRequest.getPrice())
                .language(courseCreationRequest.getLanguage())
                .tags(tags)
                .format(courseCreationRequest.getFormat())
                .endDate(courseCreationRequest.getEndDate())
                .courseType(courseCreationRequest.getCourseType())
                .coursePassword(courseCreationRequest.getCoursePassword())
                .creationDate(formattedDate)
                .authorId(response.getBody().getId())
                .build();

        // The courseKey will be automatically generated by the @PrePersist method

        Course savedCourse = courseRepository.save(course);

        if(savedCourse == null)
            log.error("Course creation failed");
        else
            log.info("Course was created successfully");
        // Http request to Chat service to create a new chat for current course
        Long chatId = webClientBuilder.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                        .scheme("http")
                        .host("chat-service")
                        .path("/chats/saveChat")
                        .queryParam("courseId",savedCourse.getId())
                        .queryParam("currentId", savedCourse.getAuthorId())
                        .build()
                )
                .retrieve()
                .bodyToMono(Long.class)
                .block();
        if(chatId == null || chatId == 0)
        {
            log.error("Error while creating chat");
        }
        savedCourse.setChatId(chatId);
        Course updatedCourse = courseRepository.save(savedCourse);
        if(updatedCourse == null || (updatedCourse.getId() != savedCourse.getId()))
            log.error("Error while updating course chatID");

        if(savedCourse != null && updatedCourse != null)
        {
            userService.updateUserItems("courses","create",savedCourse.getId(),response.getBody().getId());
        }

        return savedCourse;
    }

    @Override
    public CourseResponse getCourseResponse(Long courseId) {
        Course course = courseRepository.findById(courseId)
                .orElseThrow(() -> new ResourceNotFoundException("Course with ID " + courseId + " not found."));

        return CourseMapper.getCourseResponseFromCourse(course);
    }

    @Transactional
    @Override
    public String  uploadFile(MultipartFile file, Long courseId, String username) throws Exception {
        Course course = courseRepository.findById(courseId).get();
        // Find User sending HTTP request to users service
        // HTTP request
        ResponseEntity<UserEntityResponse> userEntityResponse = webClientBuilder.build()
                .get()  // Changed from post to get
                .uri("http://user-service/users/{username}", username)  // Adjust the URI as needed
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .toEntity(UserEntityResponse.class)
                .block();

        if(userEntityResponse == null || course == null || userEntityResponse.getBody() == null) {
           return "error";
        }

      Attachment attachment = attachmentService.saveAttachment(file, course,null, UsersMapper.responseToDto(userEntityResponse.getBody()), "course"); // upload course attachments

        String downloadUrl = ServletUriComponentsBuilder.fromCurrentContextPath()
                .path("/files/download/")
                .path(String.valueOf(attachment.getId()))
                .toUriString();
        String viewUrl = ServletUriComponentsBuilder.fromCurrentContextPath()
                .path("/files/view/")
                .path(String.valueOf(attachment.getId()))
                .toUriString();

        log.info("Download URL: " + downloadUrl);
        log.info("View URL: " + viewUrl);

        attachmentService.updateAttachmentUrls(attachment.getId(), downloadUrl, viewUrl);

        return "file successfully uploaded";
    }

    @Override
    public List<Course> getCourseByIds(List<Long> courseIds) {
        List<Course> courses = courseIds.stream()
                .map(id -> courseRepository.findById(id).get())
                .collect(Collectors.toList());
        return  courses;
    }

    @Transactional
    @Override
    public List<CourseResponse> findCourses(String type, String searchBar) {
        log.info("Course Service \"findCourses\" method is working");
        log.info("Type: '" + type + "'");
        log.info("SearchBar: '" + searchBar + "'");

        List<CourseResponse> result = new ArrayList<>();
        if (type.equalsIgnoreCase("identifier")) {
            Course course = courseRepository.findCourseByCourseKey(searchBar);
            if (course != null) {
                CourseResponse courseResponse = CourseMapper.getCourseResponseFromCourse(course);
                log.info("Was found course with title: "+courseResponse.getTitle());
                result.add(courseResponse);
            } else {
                log.warn("No course found with identifier: " + searchBar);
            }
        } else if (type.equalsIgnoreCase("title")) {
            List<CourseResponse> courses = courseRepository.searchCourses(searchBar)
                    .stream()
                    .map(CourseMapper::getCourseResponseFromCourse)
                    .collect(Collectors.toList());

            if (courses != null && !courses.isEmpty()) {
                result.addAll(courses);
            } else {
                log.warn("No courses found with title containing: " + searchBar);
            }
        } else {
            log.warn("Unknown search type: " + type);
        }

        log.info("Found " + result.size() + " course(s)");
        result.forEach(course -> log.info(course.toString()));
        return result;
    }

    @Override
    public Boolean actionCourse(Long courseId, String username, String action) {
        // HTTP request to get user
        UserEntityResponse userEntityResponse = webClientBuilder.build()
                .get()
                .uri("http://user-service/users/{username}", username)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(UserEntityResponse.class)
                .block();

        if(userEntityResponse == null)
            return false;

        // Add userId to participating  course users
        Course course = courseRepository.findById(courseId).get();

        if(course == null)
            return false;

        if(action.equals("join") && !course.getInvolvedUserIds().contains(userEntityResponse.getId()))
            course.getInvolvedUserIds().add(userEntityResponse.getId());

        if(action.equals("leave") && course.getInvolvedUserIds().contains(userEntityResponse.getId()))
            course.getInvolvedUserIds().remove(userEntityResponse.getId());

        courseRepository.save(course);

        // HTTP request to userService to update user information
        Boolean result = webClientBuilder.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .scheme("http")
                        .host("user-service")
                        .path("/users/action/"+action)  // Updated path with 'action' as part of the path
                        .queryParam("courseId", courseId)
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .block();

        return result;
    }

    @Override
    public Course findCourseById(Long courseId) {
        return courseRepository.findById(courseId).get();
    }

    @Override
    public Course findByTitle(String courseTitle) {
        return courseRepository.findByTitle(courseTitle);
    }

    @Override
    @Transactional
    public List<CourseResponse> searchCreatedCourses(String courseTitle, Long authorId) {
        List<Course> courses = (courseTitle == null || courseTitle.isEmpty())
                ? courseRepository.findAllByAuthorId(authorId)
                : courseRepository.searchCreatedCoursesByTitleAndAuthorId(courseTitle, authorId);

        if(courses == null || courses.isEmpty())
        {
            log.error("No created courses found");
            return  null;
        }
        log.info(courses.size()+" created courses found");
        return  courses.stream().map(CourseMapper::getCourseResponseFromCourse).collect(Collectors.toList());
    }

    @Override
    @Transactional
    public List<CourseResponse> searchParticipatedCourses(String courseTitle, Long userId) {
        List<Course> courses = (courseTitle == null || courseTitle.isEmpty())
                ? courseRepository.findAllByInvolvedUserIdsContaining(userId)
                : courseRepository.searchParticipatingCoursesByTitleAndUserId(courseTitle,userId);
        if(courses == null || courses.isEmpty())
        {
            log.error("No participating  courses found");
            return null;
        }
        log.info(courses.size()+" participating courses found");
        return  courses.stream().map(CourseMapper::getCourseResponseFromCourse).collect(Collectors.toList());
    }

    @Override
    public void saveEntity(Course course) {
        courseRepository.save(course);
    }

    // Course delete logic -> working
    @Override
    @Transactional
    public Boolean deleteCourse(Long courseId) {
        Course   course = courseRepository.findById(courseId).orElseThrow(() -> new ResourceNotFoundException("Course not found"));
        if(course == null)
            throw new ResourceNotFoundException("Course with ID " + courseId + " not found.");
        // Delete all course homeworks
        log.info("Course files size before homework delete: "+ course.getAttachments().size());
        List<Homework> homeworks = new ArrayList<>(course.getHomeworks());
        if(homeworks != null && !homeworks.isEmpty()) {
            for (Homework homework : homeworks) {
                homeworkService.deleteHomework(homework.getId());  // homework is removed from the course list in the homeworkService
            }
        }
        // Update course from database
        course = courseRepository.findById(course.getId()).orElseThrow(() -> new ResourceNotFoundException("Course not found"));
        log.info("Course files size after homework delete: "+ course.getAttachments().size());

        if(course.getHomeworks().isEmpty())
            log.info("Course homeworks was successfully deleted");
        else {
            log.error("Error while deleting course homeworks");
            return false;
        }
        // Delete course attachments
        List<Attachment> courseAttachments = new ArrayList<>(course.getAttachments());

        if (courseAttachments != null && !courseAttachments.isEmpty()) {
            for (Attachment attachment : courseAttachments) {
                Boolean result = attachmentService.deleteFile(attachment);
                if (result) {
                    log.info("Attachment successfully deleted");
                } else {
                    log.info("Error while deleting attachment");
                }
            }
        }

        course = courseRepository.findById(course.getId()).orElseThrow(() -> new ResourceNotFoundException("Course not found"));

        // Clear course information from userService
        userService.updateUserItems("courses","delete",course.getId(),course.getAuthorId());
        // Delete course from database
        courseRepository.delete(course);

        return true;
    }
}
